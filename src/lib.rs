extern crate hyper;
extern crate hyper_rustls;
extern crate serde_json as json;

use json::Value;
use std::io::Error as ioError;
use std::error;
use std::fmt;

use hyper_rustls::{HttpsConnector,HttpsConnectorBuilder};
use hyper::{Body,Client};
use hyper::http::{StatusCode, Request};
use hyper::client::HttpConnector;
use hyper::body::*;
static CIRCL_API_URL: &'static str = "https://cve.circl.lu/api";

/// The `Result` type used in this crate.
type Result<T> = ::std::result::Result<T, CVESearchError>;

#[derive(Debug)]
pub enum CVESearchError {
    Network(hyper::Error),
    HTTPStatusCode(StatusCode),
    IOError(ioError),
    JsonError(json::Error),
}

impl fmt::Display for CVESearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVESearchError::Network(ref err) => write!(f, "Connectivity error: {}", err),
            CVESearchError::HTTPStatusCode(code) => write!(f, "Error found: {}", code),
            CVESearchError::IOError(ref err) => write!(f, "IO error: {}", err),
            CVESearchError::JsonError(ref err) => write!(f, "Json error: {}", err),
        }
    }
}

impl error::Error for CVESearchError {
    fn description(&self) -> &str {
        match *self {
            CVESearchError::Network(ref err) => err.description(),
            CVESearchError::HTTPStatusCode(_) => "200 not received",
            CVESearchError::IOError(ref err) => err.description(),
            CVESearchError::JsonError(ref err) => err.description(),
        }
    }

    fn cause(&self) -> Option<&dyn error::Error> {
        match *self {
            CVESearchError::Network(ref err) => Some(err),
            CVESearchError::HTTPStatusCode(_) => None,
            CVESearchError::IOError(ref err) => Some(err),
            CVESearchError::JsonError(ref err) => Some(err),
        }
    }
}

impl From<hyper::Error> for CVESearchError {
    fn from(err: hyper::Error) -> CVESearchError {
        CVESearchError::Network(err)
    }
}

impl From<StatusCode> for CVESearchError {
    fn from(err: StatusCode) -> CVESearchError {
        CVESearchError::HTTPStatusCode(err)
    }
}

impl From<ioError> for CVESearchError {
    fn from(err: ioError) -> CVESearchError {
        CVESearchError::IOError(err)
    }
}

impl From<json::Error> for CVESearchError {
    fn from(err: json::Error) -> CVESearchError {
        CVESearchError::JsonError(err)
    }
}

pub struct CVESearch {
    runt : tokio::runtime::Runtime,
    client: Client<HttpsConnector<HttpConnector>>,
}

impl CVESearch {
    pub fn new() -> Self {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let https = HttpsConnectorBuilder::new()
            .with_native_roots(). https_or_http()
            .enable_http1()
            .build();

        CVESearch {
            runt :  rt,
            client: Client::builder().build(https),
        }
    }

    pub fn get(&self, url: String) -> Result<Value> {
        println!("{}", url);
        let request = Request::get(url)
        .header("User-Agent", "Rust CVE Search/1.1").header("Accept", "text/json").header("Content-Type", "text/json")
        .body(Body::empty()).unwrap();
        let res = self.runt.block_on(self.client.request(request))?;
        let ress = self.runt.block_on(to_bytes(res.into_body()))?;
        let data: Value = json::from_slice(&ress)?;
        Ok(data)
    }

    // Get all the vendors or all the products associated to a vendor
    pub fn browse<T>(&self, vendor: T) -> Result<Value>
        where Option<String>: From<T>
    {
        let url: String = format!("{}/browse/{}", CIRCL_API_URL, Option::from(vendor).unwrap_or("".into()));
        self.get(url)
    }

    // Get all the vulnerabilities per vendor and a specific product
    pub fn search(&self, vendor: String, product: String) -> Result<Value> {
        let url: String = format!("{}/search/{}/{}", CIRCL_API_URL, vendor, product);
        self.get(url)
    }

    // Get a specific CVE ID
    pub fn get_cve(&self, id: String) -> Result<Value> {
        let url: String = format!("{}/cve/{}", CIRCL_API_URL, id);
        self.get(url)
    }

    // Get last updated CVEs
    pub fn last(&self) -> Result<Value> {
        let url: String = format!("{}/last", CIRCL_API_URL);
        self.get(url)
    }

    // Get get more information about the current databases in use and when it was updated
    pub fn db_info(&self) -> Result<Value> {
        let url: String = format!("{}/dbInfo", CIRCL_API_URL);
        self.get(url)
    }
}
