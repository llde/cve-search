extern crate hyper;
extern crate hyper_rustls;
extern crate serde_json as json;

use json::Value;
use std::io::Error as ioError;
use std::error;
use std::fmt;
use std::pin::Pin;
use std::sync::atomic::{AtomicBool,Ordering};
use std::sync::{Arc,Mutex,RwLock};
use std::collections::VecDeque;
use std::thread;
use std::cell::RefCell;
use std::ops::DerefMut;

use hyper_rustls::{HttpsConnector,HttpsConnectorBuilder};
use hyper::{Body,Client};
use hyper::http::{StatusCode, Request};
use hyper::client::{ResponseFuture,HttpConnector};
use hyper::body::{to_bytes};
use tokio::runtime;

static CIRCL_API_URL: &'static str = "https://cve.circl.lu/api";

/// The `Result` type used in this crate.
type Result<T> = ::std::result::Result<T, CVESearchError>;

#[derive(Debug)]
pub enum CVESearchError {
    Network(hyper::Error),
    HTTPStatusCode(StatusCode),
    IOError(ioError),
    JsonError(json::Error),
}

impl fmt::Display for CVESearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVESearchError::Network(ref err) => write!(f, "Connectivity error: {}", err),
            CVESearchError::HTTPStatusCode(code) => write!(f, "Error found: {}", code),
            CVESearchError::IOError(ref err) => write!(f, "IO error: {}", err),
            CVESearchError::JsonError(ref err) => write!(f, "Json error: {}", err),
        }
    }
}

impl error::Error for CVESearchError {
    fn description(&self) -> &str {
        match *self {
            CVESearchError::Network(ref err) => err.description(),
            CVESearchError::HTTPStatusCode(_) => "200 not received",
            CVESearchError::IOError(ref err) => err.description(),
            CVESearchError::JsonError(ref err) => err.description(),
        }
    }

    fn cause(&self) -> Option<&dyn error::Error> {
        match *self {
            CVESearchError::Network(ref err) => Some(err),
            CVESearchError::HTTPStatusCode(_) => None,
            CVESearchError::IOError(ref err) => Some(err),
            CVESearchError::JsonError(ref err) => Some(err),
        }
    }
}

impl From<hyper::Error> for CVESearchError {
    fn from(err: hyper::Error) -> CVESearchError {
        CVESearchError::Network(err)
    }
}

impl From<StatusCode> for CVESearchError {
    fn from(err: StatusCode) -> CVESearchError {
        CVESearchError::HTTPStatusCode(err)
    }
}

impl From<ioError> for CVESearchError {
    fn from(err: ioError) -> CVESearchError {
        CVESearchError::IOError(err)
    }
}

impl From<json::Error> for CVESearchError {
    fn from(err: json::Error) -> CVESearchError {
        CVESearchError::JsonError(err)
    }
}

pub struct CVESearch {
    runt : Pin<Arc<tokio::runtime::Runtime>>,
    client: Client<HttpsConnector<HttpConnector>>,
    executor : ThreadPoolExecutor,
}



pub struct ThreadPoolExecutor{
    tasks : Arc<Mutex<VecDeque<Arc<FutureJson>>>>,
    num_thread: u32,
    current_threads : Arc<RwLock<u32>>,
    runt_handle : Pin<Arc<tokio::runtime::Runtime>>,
}

impl ThreadPoolExecutor{
    pub fn new(num_threads : u32, runt_handle : Pin<Arc<tokio::runtime::Runtime>>) -> ThreadPoolExecutor{
        ThreadPoolExecutor{tasks: Arc::new(Mutex::new(VecDeque::new())), num_thread : num_threads, current_threads:Arc::new(RwLock::new(0)), runt_handle : runt_handle}
    }

    pub fn submit(&self, response : ResponseFuture) -> Arc<FutureJson>{
        let fut = Arc::new(FutureJson::new(response , self.runt_handle.clone()));
        self.tasks.lock().unwrap().push_back(fut.clone());
     //   println!("{} {}", *self.current_threads.read().unwrap(), self.num_thread);
        if *self.current_threads.read().unwrap() < self.num_thread{
            {
                let mut guard = self.current_threads.write().unwrap();
                *guard += 1;
            }
            let arc = self.tasks.clone();
            let arc_curr_thread = self.current_threads.clone();
            thread::spawn(move ||{
                loop{
                    let option;
                    {
                        option = arc.lock().unwrap().pop_front();

                    }
                    if let Some(el) = option{
                         el.run();
                    }
                    else{
                        break;
                    }
                }
                *arc_curr_thread.write().unwrap() -= 1;
            });
        }
        fut
    }

}

pub enum PollResult<T,E>{
    Polling,
    Ready(T),
    Failed(E),
}


pub struct FutureJson{
    handle : RefCell<ResponseFuture>,
    finished : AtomicBool,
    result : Mutex<Option<Result<Value>>>,
    runt : Pin<Arc<tokio::runtime::Runtime>>
}

impl FutureJson{
    pub fn poll(&self) -> PollResult<Value, CVESearchError>{
        if self.finished.load(Ordering::SeqCst) == true {
            let resu = self.result.lock().unwrap().take().unwrap();
            match resu {
                Ok(val) => PollResult::Ready(val),
                Err(err) => PollResult::Failed(err),
            }
        }
        else {
            PollResult::Polling
        }
    }

    pub fn new(resp : ResponseFuture, runt : Pin<Arc<tokio::runtime::Runtime>>) -> FutureJson{
        FutureJson{handle : RefCell::new(resp), finished : AtomicBool::new(false), result : Mutex::new(None), runt : runt}
    }

    pub fn run(&self) -> (){
        let re = self.runt.block_on(self.handle.borrow_mut().deref_mut());
        let result : Result<Value> = match re{
            Ok(resp) =>{
                let bi = to_bytes(resp.into_body());
                let d = self.runt.block_on(bi);
                match d{
                    Ok(bytes) =>{
                        let data  = json::from_slice(&bytes);
                        match data{
                            Ok(val ) => Ok(val),
                            Err(err) => Err(CVESearchError::JsonError(err)),
                        }
                    }
                    Err(err) => Err(CVESearchError::Network(err)),
                }
            }
            Err(err) => Err(CVESearchError::Network(err)),
        };
        *(self.result.lock().unwrap()) = Some(result);
        self.finished.store(true, Ordering::SeqCst);
    }
}

unsafe impl Sync for FutureJson{} //If the RefCell is only created on the main  thread and only accessed from the callback, it's safe if we don't drop the Future while the computation is running

impl CVESearch {
    pub fn new() -> Self {
        let rt = Arc::pin(runtime::Builder::new_multi_thread()
            .enable_all().worker_threads(12)
            .build()
            .unwrap());

        let https = HttpsConnectorBuilder::new()
            .with_native_roots().https_or_http()
            .enable_http1()
            .build();

        let executor = ThreadPoolExecutor::new(12, rt.clone());
        CVESearch {
            runt :  rt,
            client: Client::builder().build(https),
            executor : executor,
        }
    }

    pub fn get(&self, url: String) -> Arc<FutureJson> {
        println!("{}", url);
        let request = Request::get(url)
        .header("User-Agent", "Rust CVE Search/1.1").header("Accept", "text/json").header("Content-Type", "text/json")
        .body(Body::empty()).unwrap();
        let res = self.client.request(request);
        self.executor.submit(res)
    }

    // Get all the vendors or all the products associated to a vendor
    pub fn browse<T>(&self, vendor: T) -> Arc<FutureJson>
        where Option<String>: From<T>
    {
        let url: String = format!("{}/browse/{}", CIRCL_API_URL, Option::from(vendor).unwrap_or("".into()));
        self.get(url)
    }

    // Get all the vulnerabilities per vendor and a specific product
    pub fn search(&self, vendor: String, product: String) -> Arc<FutureJson> {
        let url: String = format!("{}/search/{}/{}", CIRCL_API_URL, vendor, product);
        self.get(url)
    }

    // Get a specific CVE ID
    pub fn get_cve(&self, id: String) -> Arc<FutureJson>{
        let url: String = format!("{}/cve/{}", CIRCL_API_URL, id);
        self.get(url)
    }

    // Get last updated CVEs
    pub fn last(&self) -> Arc<FutureJson> {
        let url: String = format!("{}/last", CIRCL_API_URL);
        self.get(url)
    }

    // Get get more information about the current databases in use and when it was updated
    pub fn db_info(&self) -> Arc<FutureJson> {
        let url: String = format!("{}/dbInfo", CIRCL_API_URL);
        self.get(url)
    }
}
