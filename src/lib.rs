#[macro_use]
extern crate hyper;
extern crate serde_json as json;

use json::Value;
use hyper::Client;
use hyper::header::{Headers, ContentType};
use std::io::prelude::*;
use std::io::Error as ioError;
use std::error;
use std::fmt;

header! { (UserAgent, "User-Agent") => [String] }

static CIRCL_API_URL: &'static str = "https://cve.circl.lu/api";

/// The `Result` type used in this crate.
type Result<T> = ::std::result::Result<T, CVESearchError>;

#[derive(Debug)]
pub enum CVESearchError {
    Network(hyper::error::Error),
    HTTPStatusCode(hyper::status::StatusCode),
    IOError(ioError),
    JsonError(json::Error),
}

impl fmt::Display for CVESearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVESearchError::Network(ref err) => write!(f, "Connectivity error: {}", err),
            CVESearchError::HTTPStatusCode(code) => write!(f, "Error found: {}", code),
            CVESearchError::IOError(ref err) => write!(f, "IO error: {}", err),
            CVESearchError::JsonError(ref err) => write!(f, "Json error: {}", err),
        }
    }
}

impl error::Error for CVESearchError {
    fn description(&self) -> &str {
        match *self {
            CVESearchError::Network(ref err) => err.description(),
            CVESearchError::HTTPStatusCode(_) => "200 not received",
            CVESearchError::IOError(ref err) => err.description(),
            CVESearchError::JsonError(ref err) => err.description(),
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match *self {
            CVESearchError::Network(ref err) => Some(err),
            CVESearchError::HTTPStatusCode(_) => None,
            CVESearchError::IOError(ref err) => Some(err),
            CVESearchError::JsonError(ref err) => Some(err),
        }
    }
}

impl From<hyper::error::Error> for CVESearchError {
    fn from(err: hyper::error::Error) -> CVESearchError {
        CVESearchError::Network(err)
    }
}

impl From<hyper::status::StatusCode> for CVESearchError {
    fn from(err: hyper::status::StatusCode) -> CVESearchError {
        CVESearchError::HTTPStatusCode(err)
    }
}

impl From<ioError> for CVESearchError {
    fn from(err: ioError) -> CVESearchError {
        CVESearchError::IOError(err)
    }
}

impl From<json::Error> for CVESearchError {
    fn from(err: json::Error) -> CVESearchError {
        CVESearchError::JsonError(err)
    }
}

pub struct CVESearch {
    client: hyper::client::Client,
}

impl CVESearch {
    pub fn new() -> Self {
        CVESearch {
            client: Client::new(),
        }
    }

    pub fn get(&self, url: String) -> Result<Value> {
        let mut custom_headers = Headers::new();
        custom_headers.set(UserAgent("Rust CVE Search".to_owned()));
        custom_headers.set(ContentType::json());

        let mut json_str = String::new();
        let mut res = try!(self.client.get(&url).headers(custom_headers).send());
        try!(res.read_to_string(&mut json_str));

        let data: Value = try!(json::from_str(json_str.as_ref()));
        Ok(data)
    }

    // Get all the vendors or all the products associated to a vendor
    pub fn browse<T>(&self, vendor: T) -> Result<Value>
        where Option<String>: From<T>
    {
        let url: String = format!("{}/browse/{}", CIRCL_API_URL, Option::from(vendor).unwrap_or("".into()));
        self.get(url)
    }

    // Get all the vulnerabilities per vendor and a specific product
    pub fn search(&self, vendor: String, product: String) -> Result<Value> {
        let url: String = format!("{}/search/{}/{}", CIRCL_API_URL, vendor, product);
        self.get(url)
    }

    // Get a specific CVE ID
    pub fn get_cve(&self, id: String) -> Result<Value> {
        let url: String = format!("{}/cve/{}", CIRCL_API_URL, id);
        self.get(url)
    }

    // Get last updated CVEs
    pub fn last(&self) -> Result<Value> {
        let url: String = format!("{}/last", CIRCL_API_URL);
        self.get(url)
    }

    // Get get more information about the current databases in use and when it was updated
    pub fn db_info(&self) -> Result<Value> {
        let url: String = format!("{}/dbInfo", CIRCL_API_URL);
        self.get(url)
    }
}