#![allow(clippy::new_without_default)]

extern crate serde_json as json;
extern crate ureq;

use json::Value;
use std::cell::RefCell;
use std::error;
use std::fmt;
use std::io::Error as ioError;
use std::ops::DerefMut;
use std::pin::Pin;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::io::Read;

use executor_future::Futurize;
use executor_future::OperationalPromise;
use executor_future::PollResult;
use executor_future::ThreadPoolExecutor;

use ureq::{Request, Response, Agent};

static CIRCL_API_URL: &str = "https://cve.circl.lu/api";

/// The `Result` type used in this crate.
type Result<T> = ::std::result::Result<T, CVESearchError>;

#[derive(Debug)]
pub enum CVESearchError {
    Network(ureq::Error),
   // HTTPStatusCode(StatusCode),
    IOError(ioError),
    JsonError(json::Error),
}

impl fmt::Display for CVESearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVESearchError::Network(ref err) => write!(f, "Connectivity error: {}", err),
     //       CVESearchError::HTTPStatusCode(code) => write!(f, "Error found: {}", code),
            CVESearchError::IOError(ref err) => write!(f, "IO error: {}", err),
            CVESearchError::JsonError(ref err) => write!(f, "Json error: {}", err),
        }
    }
}

impl error::Error for CVESearchError {
    fn cause(&self) -> Option<&dyn error::Error> {
        match *self {
            CVESearchError::Network(ref err) => Some(err),
       //     CVESearchError::HTTPStatusCode(_) => None,
            CVESearchError::IOError(ref err) => Some(err),
            CVESearchError::JsonError(ref err) => Some(err),
        }
    }
}

impl From<ureq::Error> for CVESearchError {
    fn from(err: ureq::Error) -> CVESearchError {
        CVESearchError::Network(err)
    }
}
/*
impl From<ureq::Error> for CVESearchError {
    fn from(err: StatusCode) -> CVESearchError {
        CVESearchError::HTTPStatusCode(err)
    }
}*/

impl From<ioError> for CVESearchError {
    fn from(err: ioError) -> CVESearchError {
        CVESearchError::IOError(err)
    }
}

impl From<json::Error> for CVESearchError {
    fn from(err: json::Error) -> CVESearchError {
        CVESearchError::JsonError(err)
    }
}

pub struct CVESearch {
    agent: Agent,
    executor: ThreadPoolExecutor<Futurize<FutureJson>>,
}

pub struct FutureJson {
    handle: RefCell<Option<Request>>,
    finished: AtomicBool,
    result: Mutex<Option<Result<Value>>>,
}

impl FutureJson {
    pub fn new(resp: Request) -> FutureJson {
        FutureJson {
            handle: RefCell::new(Option::Some(resp)),
            finished: AtomicBool::new(false),
            result: Mutex::new(None),
        }
    }
}

impl OperationalPromise for FutureJson {
    type Output = Result<Value>;
    fn poll(&self) -> PollResult<Result<Value>> {
        if self.finished.load(Ordering::SeqCst) {
            PollResult::Ready(self.result.lock().unwrap().take().unwrap())
        } else {
            PollResult::Polling
        }
    }

    fn run(&self) {
        let re = self.handle.borrow_mut().take().unwrap().call();
        let result: Result<Value> = match re {
            Ok(resp) => {
                let mut reader = resp.into_reader();
                let mut cont = Vec::new();
                let d = reader.read_to_end(&mut cont);
                match d {
                    Ok(_) => {
                        let data = json::from_slice(&cont);
                        match data {
                            Ok(val) => Ok(val),
                            Err(err) => Err(CVESearchError::JsonError(err)),
                        }
                    }
                    Err(err) => Err(CVESearchError::IOError(err)),
                }
            }
            Err(err) => Err(CVESearchError::Network(err)),
        };
        *(self.result.lock().unwrap()) = Some(result);
        self.finished.store(true, Ordering::SeqCst);
    }
}

unsafe impl Sync for FutureJson {} //If the RefCell is only created on the main  thread and only accessed from the callback, it's safe if we don't drop the Future while the computation is running

impl CVESearch {
    pub fn new(threads : u32) -> Self {
        let executor = ThreadPoolExecutor::new(threads);
        CVESearch {
            agent:  Agent::new(),
            executor,
        }
    }

    pub fn get(&self, url: String) -> Futurize<FutureJson> {
        println!("{}", url);
        let request = self.agent.get(&url).set("User-Agent", "Rust CVE Search/1.1")
            .set("Accept", "text/json")
            .set("Content-Type", "text/json");

        let res = Futurize::new(FutureJson::new(request));
        self.executor.submit(&res);
        res
    }

    // Get all the vendors or all the products associated to a vendor
    pub fn browse<T>(&self, vendor: T) -> Futurize<FutureJson>
    where
        Option<String>: From<T>,
    {
        let url: String = format!(
            "{}/browse/{}",
            CIRCL_API_URL,
            Option::from(vendor).unwrap_or_else(|| "".into())
        );
        self.get(url)
    }

    // Get all the vulnerabilities per vendor and a specific product
    pub fn search(&self, vendor: String, product: String) -> Futurize<FutureJson> {
        let url: String = format!("{}/search/{}/{}", CIRCL_API_URL, vendor, product);
        self.get(url)
    }

    // Get a specific CVE ID
    pub fn get_cve(&self, id: String) -> Futurize<FutureJson> {
        let url: String = format!("{}/cve/{}", CIRCL_API_URL, id);
        self.get(url)
    }

    // Get last updated CVEs
    pub fn last(&self) -> Futurize<FutureJson> {
        let url: String = format!("{}/last", CIRCL_API_URL);
        self.get(url)
    }

    // Get get more information about the current databases in use and when it was updated
    pub fn db_info(&self) -> Futurize<FutureJson> {
        let url: String = format!("{}/dbInfo", CIRCL_API_URL);
        self.get(url)
    }
}
