#[macro_use] extern crate hyper;
extern crate serde_json;

use hyper::Client;
use hyper::header::{Headers, ContentType};
use std::io::prelude::*;
use serde_json::Value;
use std::error;
use std::fmt;

header! { (UserAgent, "User-Agent") => [String] }

static CIRCL_API_URL: &'static str = "https://cve.circl.lu/api";

#[derive(Debug)]
pub enum CVESearchError {
    Network(hyper::error::Error),
    HTTPStatusCode(hyper::status::StatusCode),
}

impl fmt::Display for CVESearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVESearchError::Network(ref err) => write!(f, "Connectivity error: {}", err),
            CVESearchError::HTTPStatusCode(sc) => write!(f, "Error found: {}", sc)
        }
    }
}

impl error::Error for CVESearchError {
    fn description(&self) -> &str {
        match *self {
            CVESearchError::Network(ref err) => err.description(),
            CVESearchError::HTTPStatusCode(_) => "200 not received"
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match *self {
            CVESearchError::Network(ref err) => Some(err),
            CVESearchError::HTTPStatusCode(_) => None,
        }
    }
}

impl From<hyper::error::Error> for CVESearchError {
    fn from(err: hyper::error::Error) -> CVESearchError {
        CVESearchError::Network(err)
    }
}

impl From<hyper::status::StatusCode> for CVESearchError {
    fn from(err: hyper::status::StatusCode) -> CVESearchError {
        CVESearchError::HTTPStatusCode(err)
    }
}

pub struct CVESearch {
    client: hyper::client::Client,
}

impl CVESearch {
    pub fn new() -> Self {
        CVESearch {
            client: Client::new(),
        }
    }

    pub fn get(&self, url: String) -> Result<Value, CVESearchError> {
        let mut custom_headers = Headers::new();
        custom_headers.set(UserAgent("Rust CVE Search".to_owned()));
        custom_headers.set(ContentType::json());
        let mut res = try!(self.client.get(&url).headers(custom_headers).send());

        let mut body = String::new();
        res.read_to_string(&mut body).unwrap();

        let data: Value = serde_json::from_str(body.as_ref()).unwrap();
        Ok(data)
    }

    // Get all the vendors or all the products associated to a vendor
    pub fn browse<T>(&self, vendor: T) -> Result<Value, CVESearchError> where Option<String>: From<T>  {
        let url: String = format!("{}/browse/{}", CIRCL_API_URL, Option::from(vendor).unwrap_or("".into()));
        self.get(url)
    }

    // Get all the vulnerabilities per vendor and a specific product
    pub fn search(&self, vendor: String, product: String) -> Result<Value, CVESearchError> {
        let url: String = format!("{}/search/{}/{}", CIRCL_API_URL, vendor, product);
        self.get(url)
    }

    // Get a specific CVE ID
    pub fn get_cve(&self, id: String) -> Result<Value, CVESearchError> {
        let url: String = format!("{}/cve/{}", CIRCL_API_URL, id);
        self.get(url)
    }

    // Get last updated CVEs
    pub fn last(&self) -> Result<Value, CVESearchError> {
        let url: String = format!("{}/last", CIRCL_API_URL);
        self.get(url)
    }

    // Get get more information about the current databases in use and when it was updated
    pub fn db_info(&self) -> Result<Value, CVESearchError> {
        let url: String = format!("{}/dbInfo", CIRCL_API_URL);
        self.get(url)
    }
}